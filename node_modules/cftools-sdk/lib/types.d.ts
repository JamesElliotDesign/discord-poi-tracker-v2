import { HttpClient } from './internal/http';
export interface CFToolsClient {
    /**
     * Returns a list of CFTools resources that have authorized the application to access them.
     *
     * This request requires an authenticated client.
     */
    getAppGrants(): Promise<AppGrants>;
    /**
     * Returns metadata about an individual player.
     *
     * This request requires an authenticated client.
     */
    getPlayerDetails(id: GenericId | GetPlayerDetailsRequest, resolveOptions?: ResolveRequestOptions): Promise<Player>;
    /**
     * Deletes the player details of the requested player. This will remove all information about the player from the
     * CFTools Cloud database. This action is irreversible.
     *
     * This request requires an authenticated client.
     */
    deletePlayerDetails(id: GenericId | DeletePlayerDetailsRequest, resolveOptions?: ResolveRequestOptions): Promise<void>;
    /**
     * Creates a leaderboard based on the requested statistic in the requested order.
     * The fields of an individual leaderboard item may vary based on the requested base statistics.
     *
     * This request requires an authenticated client.
     */
    getLeaderboard(request: GetLeaderboardRequest): Promise<LeaderboardItem[]>;
    /**
     * Returns the meta information of the priority queue of the player. If the player does
     * not have priority queue for this server, it will return null.
     *
     * This request requires an authenticated client.
     */
    getPriorityQueue(id: GenericId | GetPriorityQueueRequest, resolveOptions?: ResolveRequestOptions): Promise<PriorityQueueItem | null>;
    /**
     * Creates a priority queue entry for the given player. The entry will grant the player either permanent or
     * temporary priority queue access for the server.
     * If the player already has a priority queue entry, this entry will be deleted before the new one is created.
     *
     * This request requires an authenticated client.
     */
    putPriorityQueue(request: PutPriorityQueueItemRequest, resolveOptions?: ResolveRequestOptions): Promise<void>;
    /**
     * Drops the priority queue of the player if the player has a priority queue entry for the server. Does not error
     * when the player does not have a priority queue entry.
     *
     * This request requires an authenticated client.
     */
    deletePriorityQueue(id: GenericId | DeletePriorityQueueRequest, resolveOptions?: ResolveRequestOptions): Promise<void>;
    /**
     * Returns the meta information of the whitelist entry of the player. If the player does
     * not have a whitelist entry for this server, it will return null.
     *
     * This request requires an authenticated client.
     */
    getWhitelist(id: GenericId | GetWhitelistRequest, resolveOptions?: ResolveRequestOptions): Promise<WhitelistItem | null>;
    /**
     * Creates a whitelist entry for the given player. If the player already has a whitelist entry,
     * this entry will be deleted before the new one is created.
     *
     * This request requires an authenticated client.
     */
    putWhitelist(request: PutWhitelistItemRequest, resolveOptions?: ResolveRequestOptions): Promise<void>;
    /**
     * Drops the whitelist entry of the player if the player has a whitelist entry for the server. Does not error
     * when the player does not have a whitelist entry.
     *
     * This request requires an authenticated client.
     */
    deleteWhitelist(id: GenericId | DeleteWhitelistRequest, resolveOptions?: ResolveRequestOptions): Promise<void>;
    /**
     * Return information about a specific game server instance. These information are not related to a specific
     * CFTools Cloud server instance.
     */
    getGameServerDetails(request: GetGameServerDetailsRequest): Promise<GameServerItem>;
    /**
     * Returns basic information of the CFTools server. This is information of the server entry in the
     * CFTools Cloud platform. It does not contain the game server information, use getGameServerDetails() for such
     * information.
     */
    getServerInfo(request: GetServerInfoRequest): Promise<ServerInfo>;
    /**
     * Requests a list of currently active game sessions on the server. It will contain some meta data to the session
     * itself and you'll need an entry of the returned list when you want to interact with the corresponding player/session.
     */
    listGameSessions(request: ListGameSessionsRequest): Promise<GameSession[]>;
    /**
     * Executes a raw GameLabs action. Use this method only when you want to have more control over the parameters
     * passed to GameLabs, which is not possible with the higher-level methods (like #spawnItem() o #teleport()), or
     * when you want to execute an action that is not defined by GameLabs itself but by another extension integrating
     * with GameLabs.
     */
    gameLabsAction(request: GameLabsActionRequest): Promise<void>;
    /**
     * Spawns the requested item class, if it exists, to the player associated with the requested GameSession ID. You
     * can request a specific quantity; if you omit the parameter, the default value (1) will be used.
     *
     * Requires the GameLabs integration to be installed on the server (the default serverApiId or the one provided in the
     * request)
     */
    spawnItem(request: SpawnItemRequest): Promise<void>;
    /**
     * Heals the player associated with the GameSession. Does nothing if the player is already healed.
     *
     * Requires the GameLabs integration to be installed on the server (the default serverApiId or the one provided in the
     * request)
     */
    healPlayer(request: HealPlayerRequest): Promise<void>;
    /**
     * Kills the player associated with the GameSession.
     *
     * Requires the GameLabs integration to be installed on the server (the default serverApiId or the one provided in the
     * request)
     */
    killPlayer(request: HealPlayerRequest): Promise<void>;
    /**
     * Teleports the player associated with the requested GameSession to the coordinates requested.
     *
     * Requires the GameLabs integration to be installed on the server (the default serverApiId or the one provided in the
     * request)
     */
    teleport(request: TeleportPlayerRequest): Promise<void>;
    /**
     * Return the list of bans registered for the requested player. Both, expired and currently enforced bans, are
     * returned as a result of this method.
     *
     * If the requested user is not and was never banned so far, an empty list is returned.
     */
    listBans(request: ListBansRequest, resolveOptions?: ResolveRequestOptions): Promise<Ban[]>;
    /**
     * Creates a new entry in the banlist for the provided player. A reason is required to ban a player. It is either
     * a temporary or permanent ban, based on the provided expiration.
     */
    putBan(request: PutBanRequest, resolveOptions?: ResolveRequestOptions): Promise<void>;
    /**
     * Deletes an entry on the ban list for the provided player or ban. Given the player is not banned, this method
     * does nothing. If the player has multiple bans in the ban list, an error will be thrown. Delete the ban by
     * providing the ban you want to delete (as requested with the listBans method).
     *
     * This method will delete the ban, instead of just revoking it. The ban details will not be available in the
     * banlist afterward anymore.
     */
    deleteBan(request: DeleteBanRequest): Promise<void>;
    /**
     * Same as deleteBan(request: DeleteBanRequest) with the only difference, that this method will delete all bans
     * of the player in that banlist. This includes expired and revoked bans!
     *
     * WARNING: This method will attempt to permanently delete all bans in the banlist for that player without any further
     * confirmation.
     *
     * The performance of that operation depends on the underlying implementation. However, the time the operation takes
     * may scale linear to the amount of entries for that player on the ban list. Consult the documentation of the
     * implementation, if any, to find out more about this implementation detail.
     */
    deleteBans(request: DeleteBansRequest): Promise<void>;
    /**
     * Resolves the CFToolsId of the passed in players generic ID (e.g. a Steam ID, BE GUID or alike). The CFToolsId
     * returned identifies the same player as the passed in generic ID.
     */
    resolve(id: GenericId | {
        playerId: GenericId;
    }, resolveOptions?: ResolveRequestOptions): Promise<CFToolsId>;
}
/**
 * Request options for a request to resolve a player ID to a CFTools ID.
 */
export interface ResolveRequestOptions {
    /**
     * The CFTools Enterprise API allows a caller to automatically create a CFTools account for a SteamID64, which
     * never connected to a CFTools-enabled server. Hence, a user account for this SteamID64 does not yet exist.
     *
     * Requires a CFToolsClient with an enterprise authorization setup, otherwise the request fails with a
     * RequestForbidden error.
     *
     * @throws AccountCreationFailed if the account creation failed.
     * @throws RequestForbidden if the request is forbidden (no Enterprise account, e.g.).
     */
    autoCreateAccount?: boolean;
}
export interface Cache {
    /**
     * Returns the cached/saved value for the specified cache key. If there was never a set for the same cache key,
     * undefined is returned.
     *
     * If the value saved for the cache key is already expired, it is assumed to be not present, and undefined is
     * returned.
     */
    get<T>(cacheKey: string): T | undefined;
    /**
     * Saves the value to the specified cache key. Optionally, an expiry in seconds can be specified. If the value
     * is omitted, an implementation-details dependant default expiration is assumed.
     *
     * When implementing this interface, document what the default value for the expiry is.
     */
    set<T>(cacheKey: string, value: T, expiry?: number): void;
}
export interface AuthorizationProvider {
    /**
     * Returns an authorization that can be used together with the CFTools Data API. The token provided by this
     * function is guaranteed to be valid for enough time to make at least one request.
     *
     * The implementation decides if and how an authorization is cached between two subsequent calls to this method.
     * However, implementations should consider caching the authorization for as long as the authorization is valid (if
     * this information is available by the provider where the authorization was gathered from).
     */
    provide(client: HttpClient): Promise<Authorization>;
    /**
     * A back-channel for users of the provided authorization from provide(). Should be used, when the authorization is,
     * different than expected, reported to be expired from CFTools. This should only be used while a request was made in
     * a reasonable amount of time after the authorization was gathered from the provider.
     *
     * It's up to the provider if this information is processed and used and how it is used. The provider might evict any
     * potential cache that might be used or refresh the authorization pre-maturely. It may also just ignore this report
     * as well.
     *
     * Implementations should respect this information from clients, as it gives reasonable doubt that the currently provided
     * authorization is invalid or expired for some reason.
     */
    reportExpired(): void;
}
export declare enum AuthorizationType {
    BEARER = "Bearer",
    NOOP = "NoOp"
}
export interface Authorization {
    asHeader(): Record<string, string | string[] | undefined>;
    throwExpired(url: string): TokenExpired;
}
export declare class BearerAuthorization implements Authorization {
    readonly type: AuthorizationType;
    readonly token: string;
    readonly created: Date;
    readonly expiresAt: Date;
    /**
     * An authorization for use with the CFTools Data API. The authorization consists of a type (currently, only Bearer
     * is supported by CFTools) as well as the value (token) needed to use within the authorization. The token is an
     * opaque string, users of this information are not expected to interpret this token.
     */
    constructor(type: AuthorizationType, token: string, created: Date, expiresAt: Date);
    asHeader(): Record<string, string | string[] | undefined>;
    throwExpired(url: string): TokenExpired;
}
export declare class EnterpriseAuthorization implements Authorization {
    private readonly enterpriseToken;
    private readonly parent;
    private constructor();
    static from(token: string, auth: Authorization): EnterpriseAuthorization;
    asHeader(): Record<string, string | string[] | undefined>;
    throwExpired(url: string): TokenExpired;
}
/**
 * Configuration about how long and what should be cached when using a cached CFTools client.
 *
 * Each of the keys in this configuration applies to one method/action that the CFTools client
 * can execute. The value specifies the time in seconds the result of the action should be cached.
 */
export interface CacheConfiguration {
    appGrants: number;
    gameServerDetails: number;
    serverInfo: number;
    gameSessions: number;
    leaderboard: number;
    playerDetails: number;
    priorityQueue: number;
    whitelist: number;
    banlist: number;
    resolve: number;
}
/**
 * The CFTools Cloud identifier for a specific server in CFTools Cloud. This ID can be found in the API
 * settings of the server.
 */
export declare class ServerApiId {
    readonly id: string;
    private constructor();
    static of(id: string): ServerApiId;
}
/**
 * API Credentials are necessary for API actions which require access to a specific server (nearly any action).
 * These credentials can be retrieved from the CFTools developer portal. You need to create an application first.
 */
export declare class LoginCredentials {
    readonly applicationId: string;
    readonly secret: string;
    private constructor();
    static of(applicationId: string, secret: string): LoginCredentials;
}
export interface GenericId {
    readonly id: string;
}
export declare class BattlEyeGUID implements GenericId {
    readonly guid: string;
    private constructor();
    get id(): string;
    static of(guid: string): BattlEyeGUID;
}
export declare class SteamId64 implements GenericId {
    readonly id: string;
    private constructor();
    static of(id: string): SteamId64;
}
export declare class BohemiaInteractiveId implements GenericId {
    readonly id: string;
    private constructor();
    static of(id: string): BohemiaInteractiveId;
}
export declare class CFToolsId implements GenericId {
    readonly id: string;
    private constructor();
    static of(id: string): CFToolsId;
}
export declare enum IPAddressType {
    v4 = "v4",
    v6 = "v6"
}
export declare class IPAddress implements GenericId {
    readonly id: string;
    readonly type: IPAddressType;
    private constructor();
    static ofIpv4(address: string): IPAddress;
}
export declare function isIpAddress(o: any): o is IPAddress;
export declare enum Statistic {
    KILLS = "kills",
    DEATHS = "deaths",
    SUICIDES = "suicides",
    PLAYTIME = "playtime",
    LONGEST_KILL = "longest_kill",
    LONGEST_SHOT = "longest_shot",
    KILL_DEATH_RATIO = "kdratio",
    /**
     * @deprecated Use Statistic.KILL_DEATH_RATIO instead
     */
    KILL_DEATH_RATION = "kdratio"
}
interface IdRequest extends OverrideServerApiId {
    playerId: GenericId;
}
export interface GetPlayerDetailsRequest extends IdRequest {
}
export interface DeletePlayerDetailsRequest extends IdRequest {
}
export interface GetPriorityQueueRequest extends IdRequest {
}
export interface GetWhitelistRequest extends IdRequest {
}
export interface DeletePriorityQueueRequest extends IdRequest {
}
export interface DeleteWhitelistRequest extends IdRequest {
}
export interface GetLeaderboardRequest extends OverrideServerApiId {
    order: 'ASC' | 'DESC';
    statistic: Statistic;
    limit?: number;
}
export interface LeaderboardItem {
    id: CFToolsId;
    name: string;
    playtime: number;
    rank: number;
    suicides: number;
    kills: number;
    hits: number;
    killDeathRatio: number;
    longestKill: number;
    longestShot: number;
    deaths: number;
    environmentDeaths?: number;
}
export interface PriorityQueueItem {
    created: Date;
    createdBy: CFToolsId;
    comment: string;
    expiration: Date | 'Permanent';
}
export interface WhitelistItem {
    created: Date;
    createdBy: CFToolsId;
    comment: string;
    expiration: Date | 'Permanent';
}
export interface PutPriorityQueueItemRequest extends OverrideServerApiId {
    expires?: Date | 'Permanent';
    comment: string;
    id: CFToolsId;
}
export interface PutWhitelistItemRequest extends OverrideServerApiId {
    expires?: Date | 'Permanent';
    comment: string;
    id: CFToolsId;
}
export interface Player {
    names: string[];
    statistics: {
        dayz: DayZStatistics;
    };
    identities: {
        battleye: BattlEyeGUID;
        bohemia: BohemiaInteractiveId;
        steam: SteamId64;
        cftools: CFToolsId;
    };
    /**
     * Playtime in seconds
     */
    playtime: number;
    sessions: number;
}
export interface DayZStatistics {
    deaths: {
        animals: number;
        environment: number;
        explosions: number;
        infected: number;
        suicides: number;
        other: number;
    };
    hits: number;
    kdratio: number;
    kills: {
        animals: number;
        infected: number;
        players: number;
    };
    longestKill: number;
    longestShot: number;
    zones: HitZones;
    weapons: {
        [weaponName: string]: {
            damage: number;
            deaths: number;
            hits: number;
            kills: number;
            longestKill: number;
            longestShot: number;
            zones: HitZones;
        };
    };
}
export interface HitZones {
    brain: number;
    head: number;
    leftArm: number;
    leftFoot: number;
    leftLeg: number;
    leftHand: number;
    rightArm: number;
    rightFoot: number;
    rightHand: number;
    rightLeg: number;
    torso: number;
}
export declare enum Game {
    DayZ = "1"
}
export interface GetGameServerDetailsRequest {
    game: Game;
    ip: string;
    port: number;
}
export interface GameHost {
    address: string;
    gamePort: number;
    queryPort: number;
}
export interface GameHostGeolocation {
    available: boolean;
    city: {
        name: string | null;
        region: string | null;
    };
    continent: string;
    country: {
        code: string;
        name: string;
    };
    timezone: string;
}
export interface GameSecurity {
    battleye: boolean;
    vac: boolean;
    password: boolean;
}
export interface SteamWorkshopMod {
    fileId: number;
    name: string;
}
export interface GameEnvironment {
    perspectives: {
        firstPersonPerspective: boolean;
        thirdPersonPerspective: boolean;
    };
    time: string;
    timeAcceleration: {
        general: number;
        night: number;
    };
}
export interface GameServerItem {
    name: string;
    rank: number;
    rating: number;
    version: string;
    map: string;
    status: {
        players: {
            online: number;
            queue: number;
            slots: number;
        };
    };
    security: GameSecurity;
    online: boolean;
    mods: SteamWorkshopMod[];
    host: GameHost;
    geolocation: GameHostGeolocation;
    environment: GameEnvironment;
    attributes: {
        dlc: boolean;
        dlcs: {
            livonia: boolean;
        };
        experimental: boolean;
        hive: 'private' | 'public';
        modded: boolean;
        official: boolean;
        whitelist: boolean;
    };
}
export declare class Banlist {
    readonly id: string;
    private constructor();
    static of(guid: string): Banlist;
}
export interface ServerInfo {
    nickname: string;
    owner: CFToolsId;
    connection: {
        peerVersion: string;
        usedProtocol: 'UDP_RCON_BATTLEYE_DZ';
    };
    game: Game;
}
/**
 * Represents a session of a CFTools player in the specific game.
 * Optional information, like profile and ban information, are only available if Steam or any other third-party system
 * is available and integrated into the game.
 */
export interface GameSession {
    id: string;
    cftoolsId: CFToolsId;
    playerName: string;
    steamId: SteamId64;
    bans: {
        count: number;
        communityBanned?: boolean;
        economyBanned?: boolean;
        gameBanned?: boolean;
        vacBanned?: boolean;
    };
    live: {
        loadTime?: number | undefined;
        loaded: boolean;
        ping?: {
            actual: number;
            trend: number;
        } | undefined;
        position: {
            join?: Coordinates | undefined;
            latest?: Coordinates | undefined;
            leave?: Coordinates | undefined;
        };
    };
    profile?: {
        avatar?: URL | undefined;
        name: string;
        private: boolean;
    };
}
export interface Ban {
    id: string;
    created: Date;
    reason: string;
    expiration: Date | 'Permanent';
    status: BanStatus;
}
export declare type BanStatus = 'Ban.ACTIVE' | 'Ban.INACTIVE';
export interface ListBansRequest {
    playerId: GenericId;
    list: Banlist;
}
export interface DeleteBanRequest {
    playerId?: GenericId;
    ban?: Ban;
    list: Banlist;
}
export interface DeleteBansRequest {
    playerId: GenericId;
    list: Banlist;
}
export interface PutBanRequest {
    playerId: GenericId;
    list: Banlist;
    expiration?: Date | 'Permanent';
    reason: string;
}
export interface GetServerInfoRequest extends OverrideServerApiId {
}
export interface ListGameSessionsRequest extends OverrideServerApiId {
}
export interface SpawnItemRequest extends OverrideServerApiId {
    session: GameSession;
    /**
     * "Class name of item to be spawned
     */
    itemClass: string;
    /**
     * Amount if items to be spawned
     *
     * If omitted, the default value (1) will be used.
     */
    quantity?: number;
    /**
     * Use debug spawn method to automatically populate specific items
     *
     * If omitted, the default (false) will be used.
     */
    debug?: boolean;
    /**
     * Spawn items as a stack (only works if item supports to be stacked)
     *
     * If omitted, the default (false) will be used.
     */
    stacked?: boolean;
}
export interface HealPlayerRequest extends OverrideServerApiId {
    session: GameSession;
}
export interface KillPlayerRequest extends OverrideServerApiId {
    session: GameSession;
}
export declare type DayZGameLabsActions = 'CFCloud_SpawnPlayerItem' | 'CFCloud_TeleportPlayer' | 'CFCloud_HealPlayer' | 'CFCloud_KillPlayer' | 'CFCloud_ExplodePlayer' | 'CFCloud_StripPlayer' | 'CFCloud_DeleteVehicle' | 'CFCloud_WorldTime' | 'CFCloud_WorldWeather' | 'CFCloud_WorldWeatherSunny' | 'CFCloud_WorldWipeAI' | 'CFCloud_WorldWipeVehicles' | 'CFCloud_SpawnItemWorld' | 'CFCloud_ObjectDelete' | 'CFCloud_TerritoryFlagClear';
export interface GameLabsActionRequest extends OverrideServerApiId {
    actionCode: DayZGameLabsActions | string;
    actionContext: 'world' | 'player' | 'vehicle' | 'object';
    referenceKey: string;
    parameters: {
        [name: string]: GameLabsActionParameter;
    };
}
export declare type GameLabsActionParameter = GameLabsActionIntParameter | GameLabsActionFloatParameter | GameLabsActionStringParameter | GameLabsActionBooleanParameter | GameLabsActionVectorParameter | GameLabsActionCfItemListParameter;
export interface GameLabsActionIntParameter {
    dataType: 'int';
    valueInt: number;
}
export interface GameLabsActionFloatParameter {
    dataType: 'float';
    valueFloat: number;
}
export interface GameLabsActionStringParameter {
    dataType: 'string';
    valueString: string;
}
export interface GameLabsActionBooleanParameter {
    dataType: 'boolean';
    valueBoolean: boolean;
}
export interface GameLabsActionVectorParameter {
    dataType: 'vector';
    valueVectorX: number;
    valueVectorY: number;
    valueVectorZ: number;
}
export interface GameLabsActionCfItemListParameter {
    dataType: 'cf_itemlist';
}
/**
 * These are NOT the DayZ standard vector coordinates as seen in, e.g., COT.
 * Use the COT X value as x, the COT Y value as z and the COT Z value as y.
 */
export interface Coordinates {
    x: number;
    y: number;
    z: number;
}
export interface TeleportPlayerRequest extends OverrideServerApiId {
    session: GameSession;
    coordinates: Coordinates;
}
export interface OverrideServerApiId {
    serverApiId?: ServerApiId;
}
/**
 * Indicates that the requested resource (e.g. a server, a priority queue entry or a player ID) does not exist
 * in the CFTools Cloud database.
 */
export declare class ResourceNotFound extends Error {
    constructor(url: string);
}
/**
 * Indicates that an account could not be created through the Account Creation API using the provided identity token.
 */
export declare class AccountCreationFailed extends Error {
    constructor(identityToken: string, notice: string);
}
/**
 * Indicates that the requested resource was found, however, the action on it could not be fulfilled as the required
 * bucket (like queuepriority or whitelist) was not configured on this resource. You should only retry this request
 * when you ensured that the respective bucket is now configured for the resource correctly.
 */
export declare class ResourceNotConfigured extends Error {
    constructor(resource: string);
}
/**
 * The client tried to receive an authentication token with the provided API credentials (application ID and secret)
 * but failed with an error that indicates that the provided credentials are invalid or expired.
 */
export declare class InvalidCredentials extends Error {
    constructor();
}
/**
 * Indicates that a method/an endpoint was called which requires authentication. However, the used client instance
 * is not authenticated.
 * @see CFToolsClientBuilder.withCredentials
 */
export declare class AuthenticationRequired extends Error {
    constructor();
}
/**
 * Indicates that a method/an endpoint was called which requires a server API ID. However, the request to the method
 * did not contain a server API ID and the client did not have a default server API ID set. Re-call the method with either
 * a client which has a default server API ID set or provide on in the request parameter of the method.
 */
export declare class ServerApiIdRequired extends Error {
    constructor();
}
/**
 * The request exceeded the rate limit of the requested route. Consult the documentation to find out the limit for the
 * requested resource and try the request again after the rate limit passed.
 */
export declare class RequestLimitExceeded extends Error {
    constructor(url: string);
}
/**
 * The request attempted to create the requested resource but failed as the resource already exists.
 *
 * For an SDK method that ensures, that the resource which creation is attempted does not exist before creating it, this
 * usually means the resource was created after the resource was checked for existence or deletion, but before the
 * resource could be created by the SDK.
 */
export declare class DuplicateResourceCreation extends Error {
    constructor(url: string);
}
/**
 * The request was aborted with an internal server error indicating that an unexpected error occurred. You may want to
 * retry the request in order to see if that was a temporary problem, consult the documentation for indicators why
 * this could happen or contact the support.
 */
export declare class UnknownError extends Error {
    readonly requestId: string;
    constructor(url: string, requestId: string);
}
/**
 * The request was aborted as it exceeded the maximum time it is supposed to run. This could be the result of
 * temporary overload of the CFTools service.
 */
export declare class TimeoutError extends Error {
    constructor(url: string);
}
/**
 * The request was aborted by CFTools indicating that the service is currently unavailable. Consult the status page
 * of the service to gather information about the problem. Contact the support if the problem persists.
 */
export declare class CFToolsUnavailable extends Error {
    constructor(url: string);
}
/**
 * The request tried to interact with a resource for which the provided application credentials do not have access to.
 * Make sure you grant access to the resource for the application (see the grant flow in the documentation).
 */
export declare class GrantRequired extends Error {
    constructor(url: string);
}
/**
 * A generic error indicating that a request was rejected because the client is not allowed to either access the requested
 * resource, execute the requested action or alike.
 * More details might be available in the #message property, if the API provided it.
 */
export declare class RequestForbidden extends Error {
    readonly message: string;
    constructor(message: string);
}
export interface TokenExpiredInfo {
    readonly type: AuthorizationType;
    /**
     * The authorization token that was reported as expired.
     */
    readonly token: string;
    /**
     * The date and time when this token was last created or refreshed.
     */
    readonly created: Date;
    /**
     * When this authorization token is expected to expire.
     */
    readonly expiresAt: Date;
}
/**
 * The supplied authentication token in the request is valid but expired and needs to be re-generated.
 *
 * With regard to the SDK, this error should not happen as the token is refreshed before it expires.
 */
export declare class TokenExpired extends Error {
    readonly info: TokenExpiredInfo;
    constructor(url: string, info: TokenExpiredInfo);
}
/**
 * CFTools received an error, while fetching information from the upstream server of the requested resource. CFTools
 * needed these information in order to fulfill the request.
 */
export declare class GameServerQueryError extends Error {
    constructor(type: string);
}
export declare class AmbiguousDeleteBanRequest extends Error {
    constructor();
}
export interface BaseResource {
    id: string;
    identifier: string;
    object_id: string;
}
export interface ServerResource extends BaseResource {
    gameserver_id: string;
}
export interface AppGrants {
    banlist: {
        created: Date;
        resource: BaseResource;
    }[];
    server: {
        created: Date;
        resource: ServerResource;
    }[];
}
export {};
